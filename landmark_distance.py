# Input
#   - Two sets of landmarks to compare. Each set can contain one or more csv files.
#     The landmarks must refer to individuals present in both files. This script assumes
#     that the csv headers follow this format, the same as generated by create_csv.py: 
#       id,box_id,box_top,box_left,box_width,box_height,X0,Y0...XN,YN
#     

# Output
#   - The eculidian distance in pixels between the two landmark sets for each individual and each landmark. This is a N individual x N landmark csv file.

# Steps
#   1. Combine csv files for set one and two 
#   2. Check that the individuals are in the same order, the id does not contain directory names, there are no repeated individuals, and there are the same amount of indivudals in both sets
#   3. Find the eculidian distance for each landmark and individual between the two landmark sets

import argparse
import pandas as pd
import sys

ap = argparse.ArgumentParser()
ap.add_argument("-1", "--one", type=str, required=True, nargs='+',
    help="one or more csv files of landmarks generated by create_csv.py. For example, all of the test landmarks from n_fold_cv.py", metavar='')
ap.add_argument("-2", "--two", type=str, required=True, nargs='+',
    help="one or more csv of landmarks to compare to set one. The individuals in this set must also be in set one, there can be no repeated individuals in either set, and there are the same amount of indivudals in both sets. The column names of csv files in set two must be the same as set one", metavar='')
ap.add_argument("-i", "--id", type=str, default="id",
    help="the column name that contains the id for each individual. (default = id)", metavar='')
ap.add_argument("-p", "--path", type=str, default="/",
    help="if the ID column contains a directory name, what character separates the filename and the directory? If there is no directory in the id leave this command blank. If the id contains a '/' that is not because of a directory, set this flag to 'n' (default = /)", metavar='')
args = vars(ap.parse_args())


#   1. combine csv files for set one and two
data = []
for csv in args["one"]:
    df = pd.read_csv(csv)
    data.append(df)
df1 = pd.concat(data, ignore_index=True)
data = []
for csv in args["two"]:
    df = pd.read_csv(csv)
    data.append(df)
df2 = pd.concat(data, ignore_index=True)

#   2. Check that the individuals are in the same order, there are no repeated individuals, and there are the same amount of indivudals in both sets
if df1.shape != df2.shape:
    sys.exit("the dimensions of the landmark sets are not the same")

if not df1[args["id"]].is_unique:
    sys.exit("duplicated values in the ID colum of set one, set two not checked")
if not df2[args["id"]].is_unique:
    sys.exit("duplicated values in the ID colum of set two, set one is ok")

if args["path"] != "n":
    if df1[args["id"]].str.contains(args["path"]).any() and df2[args["id"]].str.contains(args["path"]).any(): # if the path character is in any of the id columns
        df1[args["id"]] = df1[args["id"]].str.split('/')
        df1[args["id"]] = df1[args["id"]].str[-1]
        df2[args["id"]] = df2[args["id"]].str.split('/')
        df2[args["id"]] = df2[args["id"]].str[-1]

df1 = df1.sort_values(by = args["id"])
df2 = df2.sort_values(by = args["id"])
df1 = df1.reset_index()
df2 = df2.reset_index()

print(df1)
print(df2)

print("passed QA")

#   3. Find the eculidian distance for each landmark and individual between the two landmark sets
### Doesn't work, worst case just pass the combined and formatted df1 and 2
# # create a list of column names for the X and Y coordinates
# column_names = ['X' + str(i) for i in range(40)] + ['Y' + str(i) for i in range(40)]

# # find the differences between the X and Y coordinates of the two dataframes
# differences = df1[column_names].subtract(df2[column_names])

# # square the differences
# squared_differences = differences.pow(2)

# for i in range(40):
#     # add up the squared differences for each landmark
#     sums = squared_differences[].sum(axis=1)
# print(sums)
# # find the square root of the sums to calculate the Euclidean distance for each landmark
# euclidean_distances = sums.sqrt()

# # print the Euclidean distances
# print(euclidean_distances)








### Alternative double for loop way
# # create a list of column names for the X and Y coordinates
# column_names = ['X' + str(i) for i in range(40)] + ['Y' + str(i) for i in range(40)]

# # initialize an empty list to store the Euclidean distances for each row
# euclidean_distances = []

# # loop through the rows
# for index, row in df1.iterrows():
#     # initialize a list to store the Euclidean distances for each landmark
#     row_distances = []

#     # loop through the X and Y coordinates
#     for i in range(40):
#         x1 = df1.loc[index, 'X' + str(i)]
#         y1 = df2.loc[index, 'Y' + str(i)]
#         x2 = df2.loc[index, 'X' + str(i)]
#         y2 = df2.loc[index, 'Y' + str(i)]

